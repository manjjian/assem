1. CWD 명령어를 사용하지 않고, AX의 부호를 EAX로 확장(Sign-extend)하는 시프트 명령어 시퀀스를 작성하세요.

shl eax, 16    ; 상위 16비트를 밀어내고 AX 값을 상위로 이동
sar eax, 16    ; 부호 비트를 유지하며 다시 제자리로 이동 (부호 확장 효과)

2. 명령어 세트에 회전(rotate) 명령어가 없다고 가정합시다. SHR과 조건부 점프 명령어만을 사용하여 AL 레지스터의 내용을 오른쪽으로 1비트 회전시키는 방법을 보여주세요.

    test al, 1      ; 최하위 비트(LSB) 확인 (Zero Flag 설정)
    jz L_Zero       ; 0이면 L_Zero로 점프
    shr al, 1       ; 1비트 우측 시프트
    or al, 80h      ; 최상위 비트(MSB)를 1로 설정 (회전된 비트)
    jmp L_End
L_Zero:
    shr al, 1       ; 0이었으므로 단순히 시프트만 수행
L_End:

3. 문제: EAX의 내용에 16을 곱하는 논리 시프트 명령어를 작성하세요. [shl eax, 4      ; 16은 2의 4승이므로 왼쪽으로 4비트 이동]

4. 문제: EBX를 4로 나누는 논리 시프트 명령어를 작성하세요. [shr ebx, 2      ; 4는 2의 2승이므로 오른쪽으로 2비트 이동]

5. 문제: DL 레지스터의 상위 절반(4비트)과 하위 절반을 서로 교환하는 단일 회전 명령어를 작성하세요. [ror dl, 4       ;]

6. AX 레지스터의 최상위 비트를 DX의 최하위 비트 위치로 이동시키고, DX를 왼쪽으로 1비트 이동시키는 단일 SHLD 명령어를 작성하세요. [shld dx, ax, 1]

7. 세 개의 메모리 바이트를 오른쪽으로 1비트 위치만큼 시프트하는 명령어 시퀀스를 작성하세요. (byteArray BYTE 81h,20h,33h)

; 리틀 엔디안에서는 높은 주소(offset+2)가 상위 바이트입니다.
shr byteArray+2, 1   ; 최상위 바이트 시프트 (LSB가 CF로 들어감)
rcr byteArray+1, 1   ; CF 값을 포함하여 중간 바이트 회전 시프트
rcr byteArray, 1     ; CF 값을 포함하여 최하위 바이트 회전 시프트

8. 세 개의 메모리 워드를 왼쪽으로 1비트 위치만큼 시프트하는 명령어 시퀀스를 작성하세요. (wordArray WORD 810Dh, 0C064h, 93ABh)

; 왼쪽 시프트는 최하위 워드(낮은 주소)부터 시작합니다.
shl wordArray, 1     ; 최하위 워드 시프트 (MSB가 CF로 들어감)
rcl wordArray+2, 1   ; CF 값을 포함하여 다음 워드 회전 시프트
rcl wordArray+4, 1   ; CF 값을 포함하여 최상위 워드 회전 시프트

9. -5에 3을 곱하여 결과를 16비트 변수 val1에 저장하는 명령어들을 작성하세요.

mov ax, -5
mov bx, 3
imul bx         ; 결과는 DX:AX에 저장되지만 값이 작아 AX에 들어감
mov val1, ax

10. -276을 10으로 나누고 결과를 16비트 변수 val1에 저장하는 명령어들을 작성하세요.

mov ax, -276
cwd             ; 나눗셈을 위해 AX를 DX:AX로 부호 확장
mov bx, 10
idiv bx         ; 몫은 AX, 나머지는 DX
mov val1, ax

11. 다음 C++ 표현식을 32비트 부호 없는(unsigned) 오퍼랜드를 사용하여 어셈블리 언어로 구현하세요.
   val1 = (val2 * val3) / (val4 - 3)

mov eax, val2
mul val3        ; EAX = val2 * val3 (상위비트 EDX는 0 가정)
mov ecx, val4
sub ecx, 3      ; ECX = val4 - 3
div ecx         ; EAX = 몫
mov val1, eax

12. 다음 C++ 표현식을 32비트 부호 있는(signed) 오퍼랜드를 사용하여 어셈블리 언어로 구현하세요.
   val1 = (val2 / val3) * (val1 + val2)

; 1. 나눗셈 (val2 / val3)
mov eax, val2
cdq             ; EAX를 EDX:EAX로 부호 확장
idiv val3       ; 몫은 EAX
mov ebx, eax    ; 결과를 EBX에 임시 저장

; 2. 덧셈 (val1 + val2)
mov eax, val1
add eax, val2

; 3. 최종 곱셈
imul ebx        ; EAX = EAX * EBX
mov val1, eax

13. AL에 있는 부호 없는 8비트 이진 값을 10진수 형식으로 출력하는 프로시저를 작성하세요. 입력 범위는 0~99입니다. (WriteChar만 사용 가능)

showDecimal8 PROC
    mov ah, 0       ; 나눗셈을 위해 상위 바이트 클리어
    mov bl, 10      ; 제수 설정
    div bl          ; AL = 몫(10의 자리), AH = 나머지(1의 자리)
    or  ax, 3030h   ; 두 자리 숫자를 ASCII 문자로 변환 ('0'은 30h)
    call WriteChar  ; AL(10의 자리) 출력
    mov al, ah      ; 1의 자리를 AL로 이동
    call WriteChar  ; AL(1의 자리) 출력
    ret
showDecimal8 ENDP

14. 두 개의 알 수 없는 ASCII 10진수 숫자를 더한 결과로 AX에 0072h가 들어있고 보조 캐리 플래그(AC)가 설정되었다고 가정합니다. AAA 명령어가 어떤 결과를 생성할지 설명하세요. [최종 AX 값: 0108h]

15. SUB, MOV, AND 명령어만 사용하여 x = n mod y를 계산하는 코드를 작성하세요. (y는 2의 거듭제곱)

; y가 2의 거듭제곱일 때, 나머지 연산은 (y-1)과의 AND 연산과 같습니다.
mov eax, y      ; EAX = y
sub eax, 1      ; EAX = y - 1 (비트 마스크 생성)
mov ebx, n
and ebx, eax    ; EBX = n & (y - 1)
mov x, ebx      ; 결과 저장

16. SAR, ADD, XOR 명령어만 사용하여(조건부 점프 없이) EAX 레지스터에 있는 부호 있는 정수의 절대값을 계산하는 코드를 작성하세요.

mov edx, eax    ; EAX 값을 복사
sar edx, 31     ; 부호 비트 확장 (양수면 00..00, 음수면 FF..FF)
add eax, edx    ; 음수면 1을 뺌(실제로는 -1을 더함), 양수는 변화 없음
xor eax, edx    ; 음수면 비트 반전(1의 보수), 양수는 변화 없음
; (음수일 때 1을 빼고 반전시키면 2의 보수를 취하는 것과 같아 부호가 바뀜)
