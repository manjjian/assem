1. FindLargest 프로시저 두 개의 매개변수(부호 있는 더블워드 배열의 포인터, 배열의 길이)를 받는 FindLargest라는 프로시저를 작성하세요. 이 프로시저는 배열에서 가장 큰 멤버의 값을 EAX로 반환해야 합니다. PROC 지시어와 매개변수 리스트를 사용하고, EAX를 제외한 수정되는 모든 레지스터를 보존하세요. 서로 다른 길이와 음수 값을 포함하는 배열들을 사용하여 테스트 프로그램을 작성하세요.

; PROTO 선언
FindLargest PROTO,
    ptrArray:PTR SDWORD,
    count:DWORD

.code
FindLargest PROC USES esi ecx edx,
    ptrArray:PTR SDWORD,
    count:DWORD

    mov esi, ptrArray
    mov ecx, count
    dec ecx             ; 루프 카운트 = 길이 - 1
    mov eax, [esi]      ; 첫 번째 값을 최대값으로 가정
    add esi, 4          ; 다음 요소로 이동

L1:
    mov edx, [esi]
    cmp edx, eax        ; 현재 값(EDX)과 최대 값(EAX) 비교
    jle NextElement     ; EDX <= EAX 이면 건너뜀
    mov eax, edx        ; 더 크면 EAX 갱신

NextElement:
    add esi, 4
    loop L1

    ret                 ; 최대값은 EAX에 있음
FindLargest ENDP

2. 체스 보드 (Chess Board) 회색과 흰색 사각형이 교대로 나타나는 8x8 체스 보드를 그리는 프로그램을 작성하세요. Irvine32 라이브러리의 SetTextColor와 Gotoxy 프로시저를 사용할 수 있습니다. 전역 변수 사용을 피하고, 모든 프로시저에서 선언된 매개변수를 사용하세요. 단일 작업에 집중하는 짧은 프로시저들을 사용하세요.

DrawChessBoard PROC
    mov ecx, 8          ; 행 반복 (0~7)
    mov dh, 0           ; Y 좌표

RowLoop:
    push ecx
    mov ecx, 8      ; 열 반복 (0~7)
    mov dl, 0       ; X 좌표

ColLoop:
    call Gotoxy
    
    ; 색상 결정 로직: (행 + 열)이 짝수면 회색, 홀수면 흰색 (혹은 반대)
    mov eax, 0
    mov al, dh
    add al, dl
    test al, 1      ; 홀수/짝수 확인
    jz SetGray
    
    mov eax, white + (white * 16) ; 흰색 배경
    jmp DoColor
SetGray:
    mov eax, gray + (gray * 16)   ; 회색 배경
DoColor:
    call SetTextColor
    
    mov al, ' '     ; 사각형을 그리기 위해 공백 출력
    call WriteChar
    
    inc dl          ; 다음 열
    loop ColLoop

    inc dh          ; 다음 행
    pop ecx
    loop RowLoop

    ; 색상 초기화
    mov eax, white + (black * 16)
    call SetTextColor
    ret
DrawChessBoard ENDP

3. 색상이 변하는 체스 보드 (Chess Board with Alternating Colors) 연습문제 2번을 확장하여, 500밀리초마다 색상이 있는 사각형(회색이었던 곳)의 색을 변경하여 보드를 다시 그리세요. 가능한 모든 4비트 배경색을 사용하여 16번 반복할 때까지 계속하세요. (흰색 사각형은 흰색으로 유지됩니다.)

; 메인 루프 예시
.code
main PROC
    mov ecx, 16         ; 16가지 색상 반복
    mov ebx, 0          ; 색상 인덱스

L1:
    invoke DrawBoardWithColor, ebx
    mov eax, 500
    call Delay
    inc ebx
    loop L1
    exit
main ENDP

; 매개변수로 색상을 받는 수정된 그리기 함수
DrawBoardWithColor PROC, colorCode:DWORD
    ; ... (위 2번 코드와 유사하되, SetGray 부분에서 colorCode를 사용)
    ; mov eax, colorCode
    ; shl eax, 4      ; 배경색으로 설정
    ; call SetTextColor
    ; ...
    ret
DrawBoardWithColor ENDP

4. FindThrees 프로시저 배열 어딘가에 값 3이 연속으로 세 번(3, 3, 3) 나타나면 1을 반환하고, 그렇지 않으면 0을 반환하는 FindThrees 프로시저를 작성하세요. 입력 매개변수는 배열 포인터와 배열 크기입니다.

FindThrees PROC USES esi ecx,
    ptrArray:PTR DWORD,
    count:DWORD

    mov esi, ptrArray
    mov ecx, count
    sub ecx, 2          ; 최소 3개는 비교해야 하므로 길이-2 만큼 반복
    jle NotFound        ; 길이가 3보다 작으면 실패

L1:
    mov eax, [esi]
    cmp eax, 3
    jne Next
    
    mov eax, [esi+4]    ; i+1
    cmp eax, 3
    jne Next
    
    mov eax, [esi+8]    ; i+2
    cmp eax, 3
    jne Next
    
    ; 3연속 발견
    mov eax, 1
    jmp TheEnd

Next:
    add esi, 4
    loop L1

NotFound:
    mov eax, 0
TheEnd:
    ret
FindThrees ENDP

5. DifferentInputs 프로시저 세 개의 입력 매개변수 값이 모두 다르면 EAX=1을 반환하고, 그렇지 않으면 EAX=0을 반환하는 DifferentInputs 프로시저를 작성하세요. PROTO 선언을 생성하고, 서로 다른 입력을 사용하여 5번 호출하는 테스트 프로그램을 작성하세요.

DifferentInputs PROC, v1:DWORD, v2:DWORD, v3:DWORD
    mov eax, v1
    cmp eax, v2
    je  IsEqual     ; v1 == v2
    
    cmp eax, v3
    je  IsEqual     ; v1 == v3
    
    mov eax, v2
    cmp eax, v3
    je  IsEqual     ; v2 == v3
    
    mov eax, 1      ; 모두 다름
    ret

IsEqual:
    mov eax, 0      ; 같은 것이 있음
    ret
DifferentInputs ENDP

6. 정수 교환 (Exchanging Integers) 무작위로 정렬된 정수 배열을 생성하세요. 섹션 8.4.6의 Swap 프로시저를 도구로 사용하여, 배열 내의 연속된 정수 쌍을 서로 교환하는 루프를 작성하세요.

; 배열 생성 후 루프 부분
; array DWORD ...
; count = LENGTHOF array

    mov ecx, count
    shr ecx, 1          ; 쌍의 개수 = 길이 / 2
    mov esi, OFFSET array

L1:
    ; Swap 호출 (INVOKE Swap, ADDR array[esi], ADDR array[esi+4])
    ; 또는 레지스터를 이용한 직접 교환 구현:
    mov eax, [esi]
    mov ebx, [esi+4]
    mov [esi], ebx
    mov [esi+4], eax
    
    add esi, 8          ; 2칸 이동
    loop L1

7. 최대공약수 (Greatest Common Divisor) 유클리드 알고리즘(Euclid's algorithm)을 사용하여 두 정수의 최대공약수(GCD)를 찾는 재귀 프로시저를 작성하세요. 테스트 케이스: (5,20), (24,18), (11,7), (432,226), (26,13).

GCD PROC, x:DWORD, y:DWORD
    mov eax, x
    mov ebx, y
    
    cmp ebx, 0      ; 기저 조건: y == 0
    je  ReturnX
    
    ; 재귀 단계: GCD(y, x % y)
    mov edx, 0
    div ebx         ; eax / ebx, 나머지 edx
    
    invoke GCD, ebx, edx
    ret

ReturnX:
    mov eax, x      ; 결과는 x (현재 eax에 있음)
    ret
GCD ENDP

8. 일치하는 요소 계산 (Counting Matching Elements) 두 개의 부호 있는 더블워드 배열 포인터와 배열의 길이를 받는 CountMatches 프로시저를 작성하세요. 첫 번째 배열의 요소 x_i와 두 번째 배열의 대응하는 요소 y_i가 같으면 카운트를 증가시킵니다. 일치하는 요소의 수를 EAX로 반환하세요.

CountMatches PROC USES esi edi ecx edx,
    ptr1:PTR SDWORD,
    ptr2:PTR SDWORD,
    count:DWORD

    mov esi, ptr1
    mov edi, ptr2
    mov ecx, count
    mov eax, 0          ; 일치 카운트

L1:
    mov edx, [esi]
    cmp edx, [edi]
    jne Next
    inc eax             ; 일치하면 증가

Next:
    add esi, 4
    add edi, 4
    loop L1

    ret
CountMatches ENDP

9. 근접 일치 요소 계산 (Counting Nearly Matching Elements) 두 배열 포인터, 배열 길이, 그리고 최대 허용 차이(diff)를 매개변수로 받는 CountNearMatches 프로시저를 작성하세요. 두 요소의 차이의 절대값이 diff보다 작거나 같으면 카운트를 증가시킵니다.

CountNearMatches PROC USES esi edi ecx edx ebx,
    ptr1:PTR SDWORD,
    ptr2:PTR SDWORD,
    count:DWORD,
    diff:DWORD

    mov esi, ptr1
    mov edi, ptr2
    mov ecx, count
    mov ebx, 0          ; 카운트

L1:
    mov eax, [esi]
    sub eax, [edi]      ; 차이 계산 (x - y)
    
    ; 절대값 계산
    jns CheckDiff       ; 양수면 점프
    neg eax             ; 음수면 부호 반전
    
CheckDiff:
    cmp eax, diff
    jg  Next            ; 차이가 diff보다 크면 통과
    inc ebx             ; 조건 만족 시 카운트 증가

Next:
    add esi, 4
    add edi, 4
    loop L1

    mov eax, ebx        ; 결과 반환
    ret
CountNearMatches ENDP

10. 프로시저 매개변수 표시 (Show Procedure Parameters) ShowParams라는 이름의 프로시저를 작성하여, 이 프로시저를 호출한 프로시저(caller)의 런타임 스택에 있는 32비트 매개변수들의 주소와 16진수 값을 표시하세요. 매개변수는 낮은 주소에서 높은 주소 순으로 표시되어야 합니다. 입력은 표시할 매개변수의 개수(정수) 하나입니다.

ShowParams PROC, paramCount:DWORD
    ; 스택 프레임 구조 (STDCALL 기준):
    ; [EBP]    = Old EBP (Caller's EBP)
    ; [EBP+4]  = Return Address
    ; [EBP+8]  = paramCount (ShowParams의 인자)
    
    ; 우리가 원하는 것: Caller(MySample)의 매개변수들.
    ; Caller의 매개변수는 Caller의 스택 프레임 위쪽에 위치합니다.
    ; Caller의 EBP는 [EBP]에 저장되어 있습니다.
    ; 따라서 Caller의 첫 번째 매개변수는 [Old_EBP + 8]에 있습니다.

    mov edx, [ebp]      ; EDX = Old EBP (Caller의 EBP)
    add edx, 8          ; EDX = Caller의 첫 번째 매개변수 주소
    
    mov ecx, paramCount ; 반복 횟수

L1:
    ; 주소 출력
    mov eax, edx
    call WriteHex       ; Irvine32: EAX 값을 16진수로 출력
    
    ; 구분자 출력 (예: " = ")
    mov al, '='
    call WriteChar
    mov al, ' '
    call WriteChar

    ; 값 출력
    mov eax, [edx]      ; 주소에 있는 값 로드
    call WriteHex
    call Crlf           ; 줄바꿈

    add edx, 4          ; 다음 매개변수 주소로 (Stack은 4바이트 단위)
    loop L1

    ret
ShowParams ENDP
